/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.analysis

import org.apache.spark.sql.catalyst.analysis.MultiAlias
import org.apache.spark.sql.catalyst.expressions.{
  Alias,
  Attribute,
  Cast,
  Expression,
  ExtractValue,
  Generator,
  GeneratorOuter,
  Literal,
  NamedExpression
}
import org.apache.spark.sql.catalyst.trees.TreePattern.UNRESOLVED_ALIAS
import org.apache.spark.sql.catalyst.util.{toPrettySQL, AUTO_GENERATED_ALIAS}
import org.apache.spark.sql.types.MetadataBuilder
/**
1. Spark  SQL 中处理别名解析
2. 自动生成别名
3. 处理不同类型表达式的别名
**/
object AliasResolution {
  // 检查表达式序列中 是否存在未解析的别名
  def hasUnresolvedAlias(exprs: Seq[NamedExpression]): Boolean = {
    exprs.exists(_.exists(_.isInstanceOf[UnresolvedAlias]))
  }
  // 为所有
  def assignAliases(exprs: Seq[NamedExpression]): Seq[NamedExpression] = {
    exprs
      .map(_.transformUpWithPruning(_.containsPattern(UNRESOLVED_ALIAS)) {
        case u: UnresolvedAlias => resolve(u)
      })
      .asInstanceOf[Seq[NamedExpression]]
  }
/**
**/
  def resolve(u: UnresolvedAlias): Expression = {
    // 1. 从未解析别名对象 u中 解构出 child (原始表达式)
    val UnresolvedAlias(child, optGenAliasFunc) = u
    child match {
      // 2. 如果 child 是 NamedExpression 类型, 则直接返回 child
      case ne: NamedExpression => ne
      // 3. 如果 child 是 GeneratorOuter 类型, 并且 g.resolved 为 true, 则返回 MultiAlias(go, Nil)
      case go @ GeneratorOuter(g: Generator) if g.resolved => MultiAlias(go, Nil)
      // 4. 如果 child 未解析, 则返回 u
      case e if !e.resolved => u
      // 5. 如果 child 是 Generator 类型, 则返回 MultiAlias(g, Nil)
      case g: Generator => MultiAlias(g, Nil)
      // 6. 如果 child 是 Cast 类型, 并且 ne 是 NamedExpression 类型, 则返回 Alias(c, ne.name)()
      case c @ Cast(ne: NamedExpression, _, _, _) => Alias(c, ne.name)()
      case e: ExtractValue if extractOnly(e) => Alias(e, toPrettySQL(e))()
      case e if optGenAliasFunc.isDefined =>
        Alias(child, optGenAliasFunc.get.apply(e))()
      case l: Literal => Alias(l, toPrettySQL(l))()
      case e =>
        val metaForAutoGeneratedAlias = new MetadataBuilder()
          .putString(AUTO_GENERATED_ALIAS, "true")
          .build()
        Alias(e, toPrettySQL(e))(explicitMetadata = Some(metaForAutoGeneratedAlias))
    }
  }

  private def extractOnly(e: Expression): Boolean = e match {
    case _: ExtractValue => e.children.forall(extractOnly)
    case _: Literal => true
    case _: Attribute => true
    case _ => false
  }
}
